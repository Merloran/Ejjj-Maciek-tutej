#include "SFML/Graphics.hpp"
#include <time.h>
#include <stdlib.h>
#include <windows.h>
#include <iostream>
#include <math.h>
#include <kolizja.h>

int main()
{
    sf::Clock zegar;
    sf::Time czas;
    bool sync =true;
	sf::RenderWindow window(sf::VideoMode(600, 600), "SFML WORK!");
    window.setFramerateLimit(60);
    window.setVerticalSyncEnabled(sync);
    int x;
    kolizja kolizja(x);
    sf::View view(sf::FloatRect(0, 0, 600, 600));

	sf::Texture obraz;
	if (!obraz.loadFromFile("Obrazek.jpg")){}
	sf::Texture obraz1;
	if (!obraz1.loadFromFile("Obrazek1.jpg"))	{}
	sf::Texture obraz2;
	if (!obraz2.loadFromFile("Obrazek2.jpg")){}     //wczytuje obrazki
	sf::Texture obraz3;
	if (!obraz3.loadFromFile("Obrazek3.jpg")){}
    sf::Texture obraz4;
	if (!obraz4.loadFromFile("Obrazek4.jpg")){}

	sf::Sprite zdj;
	zdj.setTexture(obraz1);
	zdj.setPosition(100,550);

	sf::Sprite zdj2;
	zdj2.setTexture(obraz);
	zdj2.setScale(sf::Vector2f(0.8,0.8));
	sf::Vector2f pozycja(300.0f, 400.0f);

	sf::Sprite zdj3;
	zdj3.setTexture(obraz2);
	zdj3.setPosition(100,200);

	sf::Sprite zdj4;
	zdj4.setTexture(obraz2);
	zdj4.setPosition(400,200);

	sf::Sprite zdj5;
	zdj5.setTexture(obraz3);

	sf::Sprite zdj6;
	zdj6.setTexture(obraz1);
	zdj6.setPosition(310,550);

	sf::Sprite zdj7;
	zdj7.setTexture(obraz1);
	zdj7.setPosition(-110,550);

	sf::Sprite zdj8;
	zdj8.setTexture(obraz4);
	zdj8.setPosition(100, 100);

	while (window.isOpen())
	{
        window.setView(view);
		sf::Event event;

		while (window.pollEvent(event))
		{
                if (event.type == sf::Event::Closed)
                window.close();
                if(event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::Escape)
                    window.close();
        }
        bool stanie;
    sf::Vector2f ruch(0.0f, 0.0f);
    if(sf::Keyboard::isKeyPressed(sf::Keyboard::Left))
        {
            ruch=sf::Vector2f(-3.0f, 0.0f);
            pozycja+=ruch;
        }
    if(sf::Keyboard::isKeyPressed(sf::Keyboard::Right))         //poruszanie sie <  >
        {
            ruch=sf::Vector2f(+3.0f, 0.0f);
            pozycja+=ruch;
        }

        czas = zegar.getElapsedTime();
        if(event.type == sf::Event::KeyReleased && event.key.code == sf::Keyboard::Up || czas.asMilliseconds()>800){stanie = false;} // warunek, ktory sprawia ze nie mozna skakac
        if(sf::Keyboard::isKeyPressed(sf::Keyboard::Up) && stanie == true)
        {
            ruch=sf::Vector2f(0.0f, -15.0f);                                                    //Skok
            pozycja+=ruch;
        }

        zdj2.setPosition(pozycja);

        pozycja.y+=3.0f;
        kolizja.kolizjoner(zdj, zdj2, pozycja, ruch, stanie, zegar);
        kolizja.kolizjoner(zdj3, zdj2, pozycja, ruch, stanie, zegar);
        kolizja.kolizjoner(zdj4, zdj2, pozycja, ruch, stanie, zegar);

        view.setCenter(pozycja.x, 350);                       //Kamera
        zdj5.setPosition(pozycja.x - 310, 40);     //tÂ³o




            if(pozycja.y >= 60000)
            {
               // window.close();
                std::cout << "GAME OVER!";
            }

		window.clear();

		window.draw(zdj5);
		window.draw(zdj);
		window.draw(zdj3);      //mapa
		window.draw(zdj4);
		//window.draw(zdj6);
		//window.draw(zdj7);
if (zdj3.getGlobalBounds().intersects(zdj2.getGlobalBounds()))  // zolte kolko
        {
            window.draw(zdj8);
        }
        sf::CircleShape kolko;
        kolko.setRadius(20);
        kolko.setFillColor(sf::Color::Yellow);
        kolko.setPosition(430, 150);
if (zdj4.getGlobalBounds().intersects(zdj2.getGlobalBounds()))  // grzybek
        {
            window.draw(kolko);
        }
		window.draw(zdj2);
		window.display();
	}
    return 0;
}



//---------------------------------------------------------------------------------------------------------------------------
//klasa kolizja.h
/*
#ifndef KOLIZJA_H
#define KOLIZJA_H
#include "SFML/Graphics.hpp"

class kolizja
{
    public:
        kolizja(int x);
        virtual ~kolizja();

        void kolizjoner(sf::Sprite obiekt, sf::Sprite &zdj2, sf::Vector2f &pozycja, sf::Vector2f &ruch, bool &stanie, sf::Clock &zegar);

    protected:

    private:
};

#endif // KOLIZJA_H
*/


//---------------------------------------------------------------------------------------------------------------------------
//klasa kolizja.cpp


/*
#include "kolizja.h"

kolizja::kolizja(int x)
{

}

kolizja::~kolizja()
{
    //dtor
}


void kolizja::kolizjoner(sf::Sprite obiekt, sf::Sprite &zdj2, sf::Vector2f &pozycja, sf::Vector2f &ruch, bool &stanie, sf::Clock &zegar)
{
        sf::FloatRect gracz(pozycja, {zdj2.getGlobalBounds().width, zdj2.getGlobalBounds().height});
        if(gracz.intersects(obiekt.getGlobalBounds()))
        {

             if (ruch==sf::Vector2f(-3.0f, 0.0f) && pozycja.x < obiekt.getPosition().x + obiekt.getGlobalBounds().width)
             {
                stanie = false;
                pozycja.x=obiekt.getPosition().x + obiekt.getGlobalBounds().width;
             }

             if (ruch==sf::Vector2f(+3.0f, 0.0f) && pozycja.x > obiekt.getPosition().x - obiekt.getGlobalBounds().width)   //Kolizja prawie dziala!
             {
                stanie = false;
                pozycja.x=obiekt.getPosition().x - zdj2.getGlobalBounds().width;
             }

             if (ruch==sf::Vector2f(0.0f, -15.0f) && pozycja.y < obiekt.getPosition().y + obiekt.getGlobalBounds().height)
             {
                stanie = false;
                pozycja.y=obiekt.getPosition().y + obiekt.getGlobalBounds().height;
                pozycja.y+=15.0f;
             }

             if(ruch==sf::Vector2f(0.0f, 0.0f) && pozycja.y > obiekt.getPosition().y - obiekt.getGlobalBounds().height)
             {
                zegar.restart();
                stanie=true;
                pozycja.y=obiekt.getPosition().y - zdj2.getGlobalBounds().height;
             }
        }
}
*/
